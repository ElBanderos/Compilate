antl AmosovGrammar;

@header {package antlr4.autogeneratedclasses;}

// Основная программа
myMainProgram:
    mainClass class*;

// Основной класс
mainClass:
    'class' identifier '{' mainMethod '}';

// Запускающий метод (main)
mainMethod:
    'void' 'main' '(' ')' '{'statement+ '}';

// Класс
class:
    'class' identifier '{' method* '}';

// Параметр
parameter:
    type identifier;

// Метод (функция)
method:
    'public'? (type|'void') identifier '(' parameters? ')' '{' methodBody '}';

// Лист параметром
parameters:
    parameter(',' parameter)*;

// Тело метода (функции)
methodBody:
    statement* (return)?;

// Типы данных
type:
    'double' | 'int' '['']'| 'boolean'| 'int' | 'char' | 'String' | identifier;

// Идентификатор
identifier:
    Identifier;

// Символы и обозначения
DIVIDE:'/';
OR:'||';
GREATER_THAN:'>';
AND:'&&';
LOWER_THAN:'<';
PLUS:'+';
MINUS:'-';
MULTIPLY:'*';
NOT:'!';
LEFT_SQUARE_BRACKET:'[';
RIGHT_SQUARE_BRACKET:']';
LP:'(';
RP:')';
RETURN:'return';
EQUALS:'=';
Bool:'true' | 'false';
SEMI_COLON:';';

// Выражение
statement:
	  nested
	| variableAssignment
	| arrayAssignment
	| continue
	| break
	| return
	| methodCall
	| ifAndElse
	| while
	| print
;

break: 'break' SEMI_COLON;
continue: 'continue' SEMI_COLON;
arrayAssignment: identifier LEFT_SQUARE_BRACKET expression RIGHT_SQUARE_BRACKET EQUALS expression SEMI_COLON;
variableAssignment: identifier EQUALS expression SEMI_COLON;
print: 'System.out.print' LP(expression) RP SEMI_COLON;
while: 'while' LP expression RP statement;
ifAndElse: 'if' LP expression RP statement ('else' statement)?;
nested: '{' statement* '}';
return: 'return' expression SEMI_COLON ;
methodCall: expression SEMI_COLON;

methodCallParams: '('(expression(',' expression)*)? ')' ;

Identifier: JavaLetter JavaLetterOrDigit*;

WS: [ \r\t\n]+ -> skip ;

LINE_COMMENT:  // Комментарий
    '//' .*? '\n' -> skip ;

STRING:	 // Строка
    '"'(ESCAPE_SEQUENCE | ~( '\\' | '"' ))* '"' ;

CHAR:  // Символ
    '\''(ESCAPE_SEQUENCE | ~( '\'' | '\\' )) '\'' ;

IntegerLiteral:
    Int ;

fragment HEX_DIGIT:
    ('0' .. '9'| 'a' .. 'f'| 'A' .. 'F') ;

fragment ESCAPE_SEQUENCE:
    '\\'('b'| 't'| 'n'| 'f'| 'r'| '"'| '\''| '\\')| UNICODE_ESC | OCTAL_ESC ;

fragment OCTAL_ESC:
    '\\'('0' .. '3')('0' .. '7')('0' .. '7') | '\\'('0' .. '7')('0' .. '7') | '\\'('0' .. '7') ;

fragment UNICODE_ESC:
    '\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT ;

fragment JavaLetter:
    [a-zA-Z$_] ;

fragment
    JavaLetterOrDigit:[a-zA-Z0-9$_] ;

fragment Int:
    Numeral ;

fragment Numeral:
    '0' | NonZeroDigit (Digits?) ;

fragment Digits:
    Digit (Digit)? ;

fragment Digit:
    '0'| NonZeroDigit ;

fragment NonZeroDigit:
    [1-9] ;

expression:
      NOT expression # notExpression
	| 'new' identifier '(' ')' # objectInstantiationExpression
    | 'new' type LEFT_SQUARE_BRACKET expression RIGHT_SQUARE_BRACKET # arrayInstantiationExpression
	|'this' # thisExpression
	| '(' expression ')' # ParenthesesExpression
	| ('+'|'-')? IntegerLiteral #integerLitExpression
	| ('+'|'-')? identifier #identifierExpression
	| STRING # stringExpression
	| CHAR # characterExpression
	| Bool # boolLitExpression
	| expression LEFT_SQUARE_BRACKET expression RIGHT_SQUARE_BRACKET # arrayAccessExpression
	| expression '.' identifier #fieldAccessExpression
	| expression ('.' identifier methodCallParams)+ # methodCallExpression
	| expression MULTIPLY expression # mulExpression
	| expression DIVIDE expression # divExpression
	| expression PLUS expression # addExpression
	| expression MINUS expression # subExpression
	| expression LOWER_THAN(EQUALS)? expression # lessThanExpression
	| expression GREATER_THAN(EQUALS)? expression # greaterthanExpression
	| expression (EQUALS|NOT) EQUALS expression # equalityExpression
	| expression AND expression # andExpression
	| expression OR expression # orExpression
;
